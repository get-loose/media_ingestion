# Brainstorm – Library Items & Media Units

Date: 2026-01-31T20:00  
Context: Consolidated notes about how `library_items`, media units, and NFO/Kodi goals fit together.

---

## 1. Ingestion Spine (Context)

- Current pre-project spine:
  - Producer stub: `dev/path_ingest.py`
  - Consumer: `app/ingest.py`
  - DB layer: `app/db.py` (`ingest_log`, `library_items`)
  - Logs:
    - Producer: `dev/host.log`
    - Consumer: `logs/ingest.log`
- `ingest_log`:
  - Immutable event history: every ingest attempt is a row.
  - Fields: `original_path`, `original_filename`, `file_size`, `detected_at`, `processed_flag`, `group_id`, `error_message`.
- `library_items`:
  - Exists in schema but not yet populated in pre-project phase.
  - Intended as “current state” of the media library.

---

## 2. Initial Thoughts (from user, consolidated)

### 2.1. Creation of `library_items` Rows

- For a **new ingested file**, even before any heavy processing, there should be a corresponding row in `library_items` so the file is represented.
- Initial values:
  - `current_path` should start as the **original path**.
  - `title` should initially be the **filename** (or filename-derived).
  - `status` should be `pending` (or similar), because:
    - Every new library item still needs at least a first pass after creation.
    - That first pass will decide what follows (e.g. filename cleanup).

### 2.2. Status and Phases

- There should be a distinction between:
  - The **first action**: creation of a `library_items` row (only for “real unique” files, not duplicates).
  - At least a **second action** that follows for every new row (triggered by `status`, e.g. `pending` or `new`).
- Question: should we use `pending` or `new` to indicate a just-created, unprocessed row?

### 2.3. File Types and Filtering

- Not every ingested file should become a `library_items` row.
- Only certain file types are relevant:
  - Audio, video, subtitles, NFO, and possibly others.
- Duplicates should be handled so that only **real unique files** become primary library items.

### 2.4. Title vs Filename vs Original Filename

- Need to distinguish:
  - `title`: how the item will be called in the `.nfo` for Kodi (affects nodes and file view).
  - `filename`: the actual on-disk filename.
- `original_filename` does **not** need to be in `library_items`:
  - It already lives in `ingest_log` as immutable history.

---

## 3. Assistant’s Structured Reaction (Consolidated)

### 3.1. Roles of `ingest_log` vs `library_items`

- `ingest_log`:
  - Event history: “we saw PATH at TIME”.
  - Append-only, no deduplication.
- `library_items`:
  - Current state: “this is a media item we care about”.
  - One row per **media unit** (see below).
  - Mutable: `current_path`, `title`, `status`, `metadata`, `fingerprint` can change over time.

### 3.2. Status Values

- Use `status` as a **coarse lifecycle** indicator:
  - `pending`: row exists, initial processing not done yet (virgin row).
  - `ready`: initial processing done (basic metadata, filename cleanup, etc.).
  - `error`: worker tried and failed (unreadable file, unsupported format, etc.).
- `pending` is likely enough to mean “created but not processed yet”; `new` may not be necessary as a separate state.

### 3.3. Fields in `library_items`

- From schema and brainstorm:
  - `ingest_id`: FK to the `ingest_log` row that last updated this item.
  - `current_path`: where the file currently lives in the library (may change).
  - `title`: display title for Kodi / NFO (may diverge from filename).
  - `status`: lifecycle state (`pending`, `ready`, `error`).
  - `metadata`: JSON for richer info (actors, tags, source website, etc.).
  - `fingerprint`: content-based identifier for deduplication.
- Additional fields discussed:
  - `filename`: current filename (derived from `current_path`).
  - `extension`: file extension (for filtering and behavior).
  - `created_at` / `updated_at`: timestamps for library-level lifecycle (distinct from `ingest_log.detected_at`).

For a brand-new item:
- `current_path` = `original_path` from `ingest_log`.
- `filename` = `Path(original_path).name`.
- `title` initially = `filename` (or filename without extension).
- `status` = `pending`.

---

## 4. Media Units and Assets

### 4.1. Media Unit Concept

- A **media unit** is a logical thing Kodi should show as one item:
  - Core media file (movie/episode/clip).
  - Its `.nfo`.
  - Its thumbnail/poster `.jpg`.
  - Possibly related subtitles and extra images.
- `library_items` rows likely represent **media units**, not every individual file.

Implications:
- Subtitles, extra images, and `.nfo` files are **assets attached to a media unit**, not separate `library_items` rows.
- Later, there may be:
  - A separate “assets” structure (table or JSON) listing associated files per media unit.

### 4.2. Folder as Early Grouping Signal

- In early phases, folder path is a cheap grouping heuristic:
  - Media units in the same folder may share:
    - Folder-level poster.
    - Folder-level `.nfo`.
    - Common tags (e.g. “Season 1”, “Collection X”).
- Later, grouping may be driven more by metadata (actors, collections, source website) than by path.

---

## 5. Kodi / NFO as the End Goal

- End goal:
  - Provide Kodi with `.nfo` files so that:
    - Files show up correctly in **file view** (even if not scraped into the library).
    - There is a `.jpg` per movie.
    - There is a `.jpg` per folder.
  - Use custom nodes that rely on NFO fields.
  - Possibly “hack” NFO fields (e.g. use “producer” to store originating website).

Implications:
- `library_items` (plus metadata) is the **source of truth**.
- `.nfo` files are **Kodi-facing projections** of that truth:
  - They can be regenerated from the DB.
  - Kodi never talks to the DB directly.
- Anything important for NFO should live in `library_items.metadata` (or columns), not only in the NFO.

---

## 6. File-Type Filtering and Deduplication

### 6.1. File-Type Whitelist (Initial Ideas)

- Video: `.mkv`, `.mp4`, `.avi`, `.mov`, `.m4v`
- Audio: `.flac`, `.mp3`, `.aac`, `.ogg`, `.m4a`
- Subtitles: `.srt`, `.ass`, `.ssa`, `.sub`, `.idx`
- NFO: `.nfo`
- Images: `.jpg`, `.jpeg`, `.png`, `.webp` (for posters/fanart)

Initial policy sketch:
- Worker creates `library_items` rows primarily for **video and audio** files (primary media units).
- Subtitles/NFO/images:
  - Either ignored initially, or
  - Attached as metadata/assets to an existing media unit.

### 6.2. Uniqueness via `fingerprint`

- `fingerprint` is the key to “real unique files”.
- Worker computes a fingerprint (hash of file content or part of it).
- When processing a new ingest:
  - If a `library_items` row with the same `fingerprint` exists:
    - Treat as duplicate or move:
      - Possibly update `current_path` and `ingest_id`.
      - Do **not** create a new `library_items` row.
  - If no matching fingerprint:
    - Create a new `library_items` row.

---

## 7. Handling New Ingests for Existing Items

### 7.1. Path Changes vs Noise

- New ingest events may relate to existing library items:
  - Manual rename of a file → new filename must be reflected in `library_items`.
  - Moving files to a new folder or renaming the folder → `current_path` must be updated.
  - New path may reveal new info (e.g. folder name contains better title/season info).
- Not all repeated ingests are meaningful:
  - Some are duplicates/noise (e.g. repeated events for the same unchanged file).

Policy sketch:
- If fingerprint and path match an existing `library_items` row and nothing else changed:
  - Mark ingest as processed.
  - Do not change `library_items`.
- If fingerprint matches but path changed:
  - Update `current_path` (and `filename`, `extension`).
  - Optionally re-run a **lightweight** path-based inference step.
- If fingerprint changed:
  - Treat more like a new version; may require a fuller pass.

### 7.2. “Full First Pass” vs “Path Changed”

- **First pass** (for brand-new items):
  - Decide if file is relevant.
  - Compute fingerprint.
  - Extract basic metadata (duration, resolution, parse filename).
  - Initialize `title`, `status`, `metadata`, etc.
- **Path-change handling** (for existing items):
  - Update `current_path` and `filename`.
  - Optionally re-parse new path for hints.
  - Probably do **not** re-run heavy media analysis if fingerprint is unchanged.

---

## 8. Relationship to `ingest_log` and Worker Flow (Next Phase Sketch)

- `ingest_log`:
  - Immutable history of what was seen, when, and where.
- `library_items`:
  - Current view of media units.
  - `ingest_id` points to the **last** ingest that updated this item.

Likely next-phase worker flow (design only):

1. Find `ingest_log` rows with `processed_flag = 0`.
2. For each:
   - If file type not in whitelist → mark processed, no `library_items` change.
   - If file type in whitelist:
     - Compute fingerprint.
     - If matching `library_items` exists:
       - Decide if this is a path change or noise.
       - Update `current_path` / `ingest_id` / `status` as needed.
     - Else:
       - Create new `library_items` row with:
         - `ingest_id` = this ingest’s id.
         - `current_path` = `original_path`.
         - `title` = initial guess (filename).
         - `status` = `'pending'`.
3. Mark `ingest_log.processed_flag = 1`.

No worker or `library_items` logic is implemented in pre-project; this is planning only.
